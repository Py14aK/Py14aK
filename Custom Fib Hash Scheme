array fib hashing scheme;
F(n - 2) &approx;
(1/3)*F(n) and F(n - 1) &approx;
(2/3)*F(n).;
f1 = 0, f2 = 1, f3 = 1;
while (f3 <= n)
	{
	f1 = f2;
f2 = f3;
f3 = f1 + f2;
fib[0] = 1 # Fib[0] stores 2nd Fibonacci No.
	fib[1] = 2 # Fib[1] stores 3rd Fibonacci No.

	# Keep Generating remaining numbers while
	# previously generated number is smaller
	i = 2
					
	while fib[i - 1] <= n:
	fib[i] = fib[i - 1] + fib[i - 2]
	i += 1

	# Return index of the largest fibonacci number
	# smaller than or equal to n. Note that the above
	# loop stopped when fib[i-1] became larger.
	return (i - 2)
;

data _null_;
	set small nobs=n;
	call symputx('obs', n);
	lenght=lenght(key);
	call symputx('string', n);
	stop;
run;
%put &n.;
%let n=fact(&n.);
%let f0=0;
%let f1=1;
%let num_n=%sysevalf(%eval(2*%eval(9**(&lenght.)))/%eval(mod(&n.,9)));
%let cel=f(n)>&n.;
%let numb_arr=1+&num_n;
478633;
10 000;
%let load = 0.8;

data _null_;
	f{0}=0;
	f{1}=1;

	If &cel. is even then
		k = n/2: F(n) = [2*lag1(F(k)) + F(k)]*F(k);

	If &cel. is odd then
		k = (n + 1)/2;
	F(n) = F(k)*F(k) + lag1(F(k)*lag1(F(k)));

	do i=2 by 1 while (fib{i} <&cel.);
		fib[i] = lag1(fib[i]) + lag2(fib[i]);
	end;
end;

	call symput(‘hsize’,left(put(p,best.)));
	stop;
	set small nobs=p;
run;

data want;
	array su{0:6}su0-su6;
	string = '183866';
	->mod(9,18386+6);
	string2=input((substr(string,&num_n.,1)));
	string3=inpuT((substr(string,1,&num_n.)))
		diffa=lenght(string)-lenght(string2);
	su{1}=sum(string2,string3);
run;

/**/
%put &obs.;
%let n=fact(&obs.);
%let f0=0;
%let f1=1;
%let num_n=%sysevalf(%eval(2*%eval(9**(&lenght1.)))/%eval(mod(&n.,9)));
%let cel=f(n)>&n.;
%let numb_arr=1+&num_n;
478633;
10 000;
%let load = 0.8;
F(n - 2) &approx;
(1/3)*F(n) and F(n - 1) &approx;
(2/3)*F(n).;
FibonacciSearch(arr, x):
	m = 0 
	while FibonacciGenerator(m) < len(arr): # 
	m = m + 1 
	offset = -1    
	while (FibonacciGenerator(m) > 1):
	i = min( offset + FibonacciGenerator(m - 2) , len(arr) - 1)
	print('Current Element : ',arr[i])
	if (x > arr[i]):
		m = m - 1
	offset = i
	elif (x < arr[i]):
	m = m - 2
	else:
	return i        
	if(FibonacciGenerator(m - 1) and arr[offset + 1] == x):
	return offset + 1
	return -1;

data fib;
	set fib;
	array f{0:100000000}_temporary_;

	do n=2 to 10000000 by 1;
		output;
	end;

	f{0}=0;
	f{1}=1;
	g=mod(n,2);

	If g1=1 then
		do;
			k=n/2;
			F{n} = (2*F{k-1} + F{k})*F{k};
		end;

	IF g1=0 THEN
		do;
			k=divide((n + 1),2);
			F{n} = F{k}*F{k} + F{k-1}*F{k-1};
		end;

	do i=1 to 100000000 by 1;
		fnum=f{i};
		output;
	end;
	;
run;

data _null_;
	array f{0:numb_arr}_temporary_;
	array fib{0:numb_arr}_temporary_;
	array seed{:}_temporary_;
	array 

		do _n_=1 by 1 until(eof);
	set  end=eof nobs=p;
	by account_rk;

	/*see how many keys we need*/
	n=fact(p);
	lenght1=LENGTHN(account_rk);
	num_n=2*9**(lenght1))/(mod(9,&n.));
	numb_arr=1+num_n;

	/*Number generator, change mod9 to special Pisano Period of interest(to be developed better),*/
	string2=input((substr(account_rk,&num_n.,1)));
	string3=inpuT((substr(account_rk,1,&num_n.)))
		fi(_n_)=mod(9,sum(string2,string3));

	if fi(_n_)>lag1(fi(_n_)) then
		_ij=fi(_N_);
end;
	else _ij=fi(1);
end;

	/*Use Zeckendorf’s Theorem (Non-Neighbouring Fibonacci Representation) to find a fib sum that equals our number*/
	f{0}=0;
	f{1}=1;
	f{&num_n./2};

	do k=9 by 1 until(k=&num_n./2);
		set fib point=9 end=lr1;
		f{k}=fnum;
	end;

	set end=lr;

	do n=&num_n./2 by 1  until(F(n)>=_ij);
		cel=mod(n,2);

		If cel is 1 then
			k = n/2: F(n) = [2*lag1(F(k)) + F(k)]*F(k);
		else k = (n + 1)/2;
		F(n) = F(k)*F(k) + lag1(F(k)*lag1(F(k)));

		/*FInd upper bound in log(N) time, the use my variation of a greedy algo*/

			if lag1(f{n})<=_ij and f{n}>_ij then
			fib{n}=lag1(f{n});
		_diff=_ij- lag1(F{n});

		DO n=2 by 1 while(f(n)<_diff);
			if F(n)=_diff then
				F(n)=fib(n);
		end;

		do until (_ij=.);
			_ij=lag1(_ij);

			do over F;
				if lag1(f{n})<=_ij and f{n}>_ij then
					fib{n}=lag1(f{n});
				_diff=_ij- lag1(F{n});

				if F(n)=_diff then
					fib{n}=F(n);
			end;
		end;
run;

do while(fib{i}<_Ij);
	fib[i] = lag1(F(n)) + lag2(F(n));
	i+1;
end;

data want;
	set lgd.mopla7;
	array su{0:6}su0-su6;

	/*string = '183866';->mod(9,18386+6);*/
	string2=input((substr(string,&num_n.,1)));
	string3=inpuT((substr(string,1,&num_n.)))
		diffa=lenght(string)-lenght(string2);
	su{1}=mod(9,sum(string2,string3));
run;

data match (keep=key s_sat l_sat);
	array hkey (0:&hsize) _temporary_;
	array hsat (0:&hsize) _temporary_;
	hKey(0)=0;
	hkey{1}=1;

	** load table with keys from SMALL;

	do until (eof1);
-		set keys end=eof1;
		by fib;

		do fi=&hsize to 1 by -1 until (hkey(fi)=. or hkey(fi)=fib);
			if fi < 0 then
				fi = &hsize-1;
		end;

		hkey(h) = key;
		hsat(h) = s_sat;
	end;

	** search table for each key from LARGE and output matches;

	do until (eof2);
		set large end=eof2;

		do h=mod(key,&hsize) by -1 until (hkey(h) = .);
			if h < 0 then
				h = &hsize-1;

			if hkey(h) = key then
				do;
					s_sat = hsat(h);
					output;
					leave;
				end;
		end;
	end;

	stop;
run;

/**/

%macro array_fib();
	put &obs.;
